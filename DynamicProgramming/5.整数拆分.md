[题目链接：LeetCode.343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)

## 题目

给定一个正整数 *n*，将其拆分为**至少**两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

**示例 1:**

```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

**示例 2:**

```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```

 **说明:** 你可以假设 *n* 不小于 2 且不大于 58。

题解

方法一：动态规划

1. 确定 dp 数组以及下标的含义

dp[i]：拆分 i 获得的最大乘积。

2. 递推公式

i 拆分成至少两个正整数的和。

假设 i 拆分出来的第一个正整数为 j (1 <= j  < i)。有以下两种情况：

* 将 i 拆分成 j  和 i - j，且 i - j 不再拆分成多个正整数。乘积为 j * (i - j)。
* 将 i 拆分成 j 和 i - j，且 i - j 继续拆分成多个正整数。乘积为 j * dp[i - j]。

首先，dp[i] 与 dp[i - j] 有关系，所以，需要先计算出dp[0],dp[1]...dp[n]。

另外，j 的取值范围是 [1, i)。对于固定的 j，  最大乘积 res 为` Math.max(j * (i - j), j * dp[i - j])` 。对于每个j，比较取出最大的乘积。

3. 初始化

0 和 1无法拆分。dp[0] = 0, dp[1] = 0。n = 2，最大乘积 dp[2] = 1。

4. 遍历顺序

dp [i] 是依靠 dp [i - j] 的状态，所以遍历 i 一定是从前向后遍历，先有 dp [i - j] 再有 dp [i]。

j 的取值范围是 [1, i)。

```java
class Solution {
    public int integerBreak(int n) {
        int[] dp = new int[n + 1];
        for (int i = 2; i <= n; i++) {
            int curMax = 0;
            for (int j = 1; j < i; j++) {
                curMax = Math.max(curMax, Math.max(j * (i - j), j * dp[i - j]));
            }
            dp[i] = curMax;
        }
        return dp[n];
    }
}
```

* 时间复杂度：O(n^2)。对于从 2 到 n 的每一个整数都要计算对应的 dp 值，计算一个整数对应的 dp 值需要 O(n) 的时间复杂度，因此总时间复杂度是 O(n^2)。
* 空间复杂度：O(n)。

方法二：数学







