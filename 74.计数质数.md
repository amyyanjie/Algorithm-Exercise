---
title: 74.计数质数
english_title: count-primes
date: 2020-12-04 10:41:23
tags: LeetCode
categories: /DataStructure
---

## 题目

统计所有小于非负整数 *`n`* 的质数的数量。

**示例 1：**

```
输入：n = 10
输出：4
解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
```

**示例 2：**

```
输入：n = 0
输出：0
```

**示例 3：**

```
输入：n = 1
输出：0
```

**提示：**

- `0 <= n <= 5 * 106`

## 题解

质数的定义：在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。

**除了 1 外，不能被小于 n 的数 整除。0和1不是质数。**

1、枚举法

列举出 [2, n - 1] 的数，判断每个数是否为质数。

判断 x 是否为质数：列举出 [2, sqrt(x)] 所有数，看能否被 x 整除。这里缩小范围到根号x。

```java
    public int countPrimes(int n) {
        int count = 0;
        for (int i = 2; i < n; i++) {
            count += isPrime(n) ? 1 : 0;
        }
        return count;
    }

    private boolean isPrime(int n) {
        for (int i = 2; i * i <= n; ++i) {
            if (n % i == 0) {
                return false;
            }
        }
        return true;
    }
```

* 时间复杂度：O(n * sqrt(n))。
* 空间复杂度：O(1)。

2、厄拉多塞筛法（埃氏筛）

该算法由希腊数学家厄拉多塞（ Eratosthenes）提出，称为厄拉多塞筛法，简称埃氏筛。

我们考虑这样一个事实：如果 x 是质数，那么大于 x 的 x 的倍数 2x,3x,… 一定不是质数，因此我们可以从这里入手。

`isPrime ` 数组从小到大放 小于 n 的所有数。`isPrime[i]`为 1 表示是质数。

* 先使数组元素都为 1，表示默认为质数。

* 从小到大遍历每个数，如果这个数为质数，则将其所有的倍数都标记为合数（除了该质数本身），即 0。

  **注意其倍数可能会 int 溢出，需要转换成 long类型。**

* 如果这个数为合数，则它一定是某个小于 x 的质数 y 的整数倍，故根据此方法的步骤，我们在遍历到 y 时，就一定会在此时将 x 标记为 `isPrime[x]=0`。

**未优化：**

```java
    public int countPrimes(int n) {
        int count = 0;
        int[] isPrime = new int[n];// 放数字[0, n-1]，下标对应数字
        Arrays.fill(isPrime, 1);// 使默认都为1：质数
        for (int i = 2; i < n; i++) {// 从数字 2 开始，2 为质数
            if (isPrime[i] == 1) {
                count++;
                // 使 i 的倍数都变成合数
                // 需要转换成 long类型，比如 499000 * 499000，int结果为 -107103168
                for (int k = 2; (long)k * i < n; k++) { //k * i 的最大范围是小于 n
                    isPrime[k * i] = 0;
                }
            }
        }
        return count;
    }
```

**优化：**

以上逻辑中：对于一个质数 i ，将 i 的倍数都变成合数，倍数 k 从 2 开始递增，则 2倍、3倍、4倍.....

比如 i=2，获取其 2倍、3倍、4倍、5倍……

比如 i=3，获取其 2倍、3倍、4倍、5倍……

其中有冗余，i=3 时，k 可直接从 3 开始。3 的 2 倍 相对于 2 的 3倍已经冗余。

**倍数 可优化成 i 倍 开始。**

```java
    public int countPrimes(int n) {
        int count = 0;
        int[] isPrime = new int[n];// 放数字[0, n-1]，下标对应数字
        Arrays.fill(isPrime, 1);// 使默认都为1：质数
        for (int i = 2; i < n; i++) {// 从数字 2 开始，2 为质数
            if (isPrime[i] == 1) {
                count++;
                // 使 i 的倍数都变成合数，倍数从 i 开始递增
                for (int k = i; (long) k * i < n; k++) {
                    isPrime[k * i] = 0;
                }
            }
        }
        return count;
    }
```



[题目链接：LeetCode No.204. 计数质数](https://leetcode-cn.com/problems/count-primes/)