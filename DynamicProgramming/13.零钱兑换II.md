[题目链接：LeetCode.518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

## 题目

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

**示例 1：**

```
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

**提示：**

- `1 <= coins.length <= 300`
- `1 <= coins[i] <= 5000`
- `coins` 中的所有值 **互不相同**
- `0 <= amount <= 5000`

## 题解

每一种面额的硬币有无限个。这是完全背包类型。

* dp[j] 表示从[0,i] 的硬币，凑成总金额 j 的硬币组合数为 dp[j]。
* 递推公式：对于当前硬币面额 coins[i]
  * 可选择将 coins[i] 加入组合，组合数应等于  j - coins[i] 的 组合数，即 dp[j - coins[i]]。
  * 可选择不加入，组合数还是dp[j]。
  * 即 dp[j] = dp[j] + dp[j -  coins[i]]
* 初始化：dp[0] = 1。这是递推公式的基础，当j  =  coins[i] 时，若加入硬币面额i，可以单独组合。

* 遍历顺序：本题要求凑成总和的组合数。

  * 如果是外层遍历物品（面额），内层遍历背包（总额）：

    ```java
    for (int i = 0; i < coins.length; i++) { // 遍历物品
        for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量
            dp[j] += dp[j - coins[i]];
        }
    }
    ```
    在计算 dp[i] 的值时，可以确保金额之和等于 i 的硬币面额的顺序，由于顺序确定，因此不会重复计算不同的排列。
    
    例如 coins=[1,2]，在计算dp[3]时，一定是先遍历硬币面额 1 后遍历硬币面额 2，只会出现以下 2 种组合：1+1+1和 1+2。面额2不可能出现在面额1前面，所以不会有 2+1 的重复组合。
    
    **所以外层 for 循环遍历物品，内层 for 遍历背包，dp[j]计算的是组合数。**
    
    如果是外层遍历总额，内层遍历面额：
    
    ```java
    for (int j = 0; j <= amount; j++) { // 遍历背包容量
        for (int i = 0; i < coins.length; i++) { // 遍历物品
            if (j - coins[i] >= 0) {
              dp[j] += dp[j - coins[i]];
              System.out.println("容量为"+j+"的组合为："+coins[i]+"和"+ (j -  coins[i])+"，组合数dp[j]为"+dp[j]);
            }
        }
    }
    ```
    
    对于背包容量的每个值，都要经过1 和 2 的计算。例如 coins=[1,2]，在计算dp[3]时：
    
    j = 3，coins[0] = 1：若选择该面额1，剩余面额为2。组合1+2。
    
    j = 3，coins[1] = 2：若选择该面额2，剩余面额为1。组合 2+1。
    
    **所以外层 for 遍历背包，内层 for 循环遍历物品，dp[j]计算的是排列数。**
    
  * 因此，本题求组合数：外层遍历硬币面额，内层遍历金额总额。

  * 因为完全背包，每硬币面额有无限个，可以重复选择，内层循环从小到大遍历总额。

综上，本题是完全背包求组合，外层遍历物品，内层遍历背包。

```java
class Solution {
    public int change(int amount, int[] coins) {
        int dp[] = new int[amount + 1];
        // dp[j] 表示在[0,i]硬币中，能凑成总金额为j的组合数。
        dp[0] = 1;
        for (int i = 0; i < coins.length; ++i) {
            for (int j = coins[i]; j <= amount; ++j) { // 正序遍历
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
}
```

