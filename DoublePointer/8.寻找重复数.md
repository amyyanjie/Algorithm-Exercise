[题目链接：LeetCode.287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)

## 题目

给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `1` 到 `n` 之间（包括 `1` 和 `n`），可知至少存在一个重复的整数。

假设 `nums` 只有 **一个重复的整数** ，找出 **这个重复的数** 。

你设计的解决方案必须不修改数组 `nums` 且只用常量级 `O(1)` 的额外空间。 

**示例 1：**

```
输入：nums = [1,3,4,2,2]
输出：2
```

**示例 2：**

```
输入：nums = [3,1,3,4,2]
输出：3
```

**示例 3：**

```
输入：nums = [1,1]
输出：1
```

**示例 4：**

```
输入：nums = [1,1,2]
输出：1
```

**提示：**

- `1 <= n <= 105`
- `nums.length == n + 1`
- `1 <= nums[i] <= n`
- `nums` 中 **只有一个整数** 出现 **两次或多次** ，其余整数均只出现 **一次**

**进阶：**

- 如何证明 `nums` 中至少存在一个重复的数字？
- 你可以设计一个线性级时间复杂度 `O(n)` 的解决方案吗？

## 题解

寻找重复的数，很容易想到用哈希表。但本题要求只用常量级 `O(1)` 的额外空间，因此不符合本题要求。

实际工作中不会用【时间换空间】。本题是有特殊的场景和限制。

### 方法一：二分查找（*）

* 为什么可以使用二分查找

题目要找的是一个整数，并且这个整数有明确的范围，因此可以使用二分法。

查找一个有范围的整数可以使用「二分查找」。这是「二分查找」的典型应用。

* 本题二分查找的思路

  > n + 1 个整数，放在长度为 n 的数组里，根据「抽屉原理」，至少会有 1 个整数是重复的；

  > 抽屉原理：把 10 个苹果放进 9 个抽屉，一定存在某个抽屉放至少 2 个苹果。 
  >

**重点理解：**本题二分查找是在[1, 2, 3,..., n]中二分查找一个数，这个数在nums中重复。而并不是在输入数组nums中二分查找一个数。

每次猜一个数（有效范围[left, right]中位于中间的数mid）。然后统计数组nums中小于等于mid的元素的个数`cnt`。

如果`cnt`严格大于mid，根据抽屉原理，重复元素就在区间[left, mid]中。否则，重复元素就在区间[mid+1, right]中。

```java
class Solution {
    public int findDuplicate(int[] nums) {
        int n = nums.length;
        int left = 1, right = n - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            // 统计nums中<=mid的元素数量
            int cnt = 0;
            for (int num : nums) {
                if (num <= mid) {
                    cnt++;
                }
            }
            // 如果 cnt>mid，区间在[left,mid]
            // 根据抽屉原理，小于等于 4 的个数如果严格大于 4 个，此时重复元素一定出现在 [1..4] 区间里
            if (cnt > mid) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }// 跳出循环时left与right相等
        return left; 
    }
}
```

时间复杂度：O(nlogn)。二分查找的时间复杂度是O(logn)，每次查找内部会进行时间复杂度为O(n)的一次for循环。

空间复杂度：O(1) 。

### 方法二：循环链表快慢指针（*）

* 如何将本题与循环链表建立关联

使用环形链表II（[LeetCode.142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)）的方法解题的**关键在于理解如何将输入的数组看作为链表**。

已知，输入数组nums的元素个数为 n+1，即数组下标范围为[0, n]。nums中的数字范围为[1, n]。

**通过将数组下标n 与下标位置数字 nums[n]建立映射关系**。

考虑两种情况：

1. 如果数组中没有重复的数字。如 [1,3,4,2]。

   n 与 nums[n] 建立的映射关系为0->1, 1->3, 2->4, 3-> 2。

   从下标 0 出发，得到下标0位置的数字，再以这个值为新的下标，得到下标位置数字，以此类推，得到的链表为 0 -> 1 -> 3 -> 2 -> 4 -> null。

2. 如果数字中有重复的数字。如 [1,3,4,2,2]。

   n 与 nums[n] 建立的映射关系为0->1, 1->3, 2->4, 3->2, 4->2。

   从下标 0 出发，得到下标0位置的数字，再以这个值为新的下标，得到下标位置数字，以此类推，得到的链表为 0 -> 1 -> 3 -> 2 -> 4 -> 2 -> 4 -> 2 ->......。

数组中如果有重复的数，就会产生多对一的映射，这样，形成的链表就一定会有环路。

* 循环链表的解题思路

则题解与环形链表II方法相同。快慢指针从起点0出发，慢指针每次移动一步，快指针每次移动两步。

当快慢指针相遇后，将ptr指针放置起点0，ptr和slow指针每次同时移动一步，相遇的点即是答案。

```java
class Solution {
    public int findDuplicate(int[] nums) {
        // 环形链表
        int slow = 0, fast = 0;
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow != fast);
        // 快慢指针相遇。此时ptr指针从0出发，与慢指针每次同时移动一步，直到相遇，相遇点即为入环点
        int ptr = 0;
        while (ptr != slow) {
            ptr = nums[ptr];
            slow = nums[slow];
        }
        return slow;
    }
```

* 时间复杂度：O(n)。
* 空间复杂度：O(1)。