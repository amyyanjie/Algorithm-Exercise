[题目链接：LeetCode.377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

## 题目

给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

**示例 1：**

```
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
```

**示例 2：**

```
输入：nums = [9], target = 3
输出：0
```

**提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 1000`
- `nums` 中的所有元素 **互不相同**
- `1 <= target <= 1000` 

**进阶：**如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？

## 题解

顺序不同的序列被视作不同的组合。因此**本题要求计算的是选取元素的排列数**。

如果要求把排列都列出来的话，只能使用回溯法暴搜。

本题要求返回排列的个数，使用动态规划。

*  dp[i]：选取的元素总和为 i 的排列数。

* 递推公式：

  例如 [1, 2, 3]。对于dp[10]，排列方式可以有三种情况：

  * 排列以 1 结尾。如果我们得到了总和为9的排列，所有排列后拼接1即可。所以这种情况排列数 y1 = dp[10 - 1]。
  * 排列以 2 结尾。如果我们得到了总和为8的排列，所有排列后拼接2即可。所以这种情况排列数 y2 = dp[10 - 2]。
  * 排列以 3 结尾。如果我们得到了总和为7的排列，所有排列后拼接3即可。所以这种情况排列数 y3  = dp[10 - 3]。

  ​       所以dp[10] = y1 + y2 + y3。而 x1，x2，x3 又可以用同样的办法从子问题得到。

  遍历 i 从 1 到 target，对于每个 i，进行如下操作：

  遍历数组的每个元素 num，当 num≤i 时，将dp[i−num] 的值加到 dp[i]。
  最终得到 dp[target] 的值即为答案。

  即 dp[i] += dp[i - num]。
  
* 初始化：dp[0] = 1。只有当不选取任何元素时，元素之和才为 0，因此只有 1 种方案。
  
*  遍历顺序：

   从状态转移方程的分析可知，**求排列数就是外层 for 遍历背包，内层 for 循环遍历物品**。

   
   
   因为外层循环是遍历从 1 到 target 的值，内层                   循环是遍历数组 nums 的值，在计算 dp[i] 的值时，nums 中的每个小于等于 i 的元素都可能作为元素之和等于 i 的排列的最后一个元素。

因为`nums` 中的所有元素互不相同，内层循环时直接遍历nums即可，不用考虑去重。

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target + 1];
        dp[0] = 1;
        // 排列：外层遍历背包，内层遍历物品
        for (int i = 0; i <= target; ++i) {
            for (int num : nums) {
                if (i >= num) {
                    dp[i] += dp[i - num];
                }
            }
        }
        return dp[target];
    }
}
```

#### 进阶思考

假设给定的数组中含有负数：

如果[a, -b, ...]，那么对于任意target的排列，在排列后加上 b 个 a 和 a 个 -b，得到的和仍为 target。b x a + a * (-b) = 0。可以不限次添加。

因此若数组中含有负数，会导致出现无限长度的排列。

如果允许负数出现，则必须限制排列的最大长度，避免出现无限长度的排列，才能计算排列数。

